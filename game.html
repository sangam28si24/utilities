<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smash Lab</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Matter.js (Physics Engine) and MediaPipe (Hand Tracking) -->
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.18.0/build/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
    
        canvas {
            display: block;
            touch-action: none;
            background: linear-gradient(170deg, #1a202c 0%, #2d3748 100%);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        .input_video {
            display: none;
        }
      
        #message-overlay {
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center h-screen p-4 md:p-6">

    <div class="w-full max-w-5xl mx-auto flex flex-col items-center space-y-4">
        <header class="text-center w-full flex justify-between items-center px-4">
            <div></div> <!-- Spacer -->
            <div>
                 <h1 class="text-3xl md:text-4xl font-bold text-cyan-400">Smash Lab</h1>
                 <p class="text-gray-400 mt-1">Hit all the red targets!</p>
            </div>
            <div id="score-container" class="text-2xl font-bold text-yellow-400">
                Targets: <span id="score">0 / 5</span>
            </div>
        </header>

        <!-- Container for the canvas and video elements -->
        <div id="game-container" class="w-full aspect-video relative rounded-xl overflow-hidden shadow-2xl border-2 border-gray-700">
            
            <canvas id="game-canvas"></canvas>
            
            <video class="input_video"></video>
            
           
            <div id="message-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-center p-4 z-10">
                <div id="loader" class="border-4 border-t-4 border-gray-600 border-t-cyan-400 rounded-full w-12 h-12 animate-spin"></div>
                <p id="message-text" class="mt-4 text-lg font-semibold">Initializing Camera & Models...</p>
            </div>
        </div>
        
        <div class="flex space-x-4">
             <button id="reset-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-transform transform hover:scale-105 active:scale-95">
                Reset Game
            </button>
        </div>
    </div>

    <script type="module">
        // Get DOM elements
        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.getElementById('game-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const messageOverlay = document.getElementById('message-overlay');
        const messageText = document.getElementById('message-text');
        const loader = document.getElementById('loader');
        const resetButton = document.getElementById('reset-button');
        const scoreElement = document.getElementById('score');

        // --- Matter.js Setup ---
        const { Engine, Events, Runner, World, Bodies, Body, Composite, Constraint } = Matter;

        let engine;
        let runner;
        const objects = [];
        const targets = [];
        const particles = []; // For explosion effects
        let score = 0;
        let totalTargets = 0;
        
        // --- Hand Tracking Variables ---
        let rawHandLandmarks = null;
        let smoothedHandLandmarks = null;
        const SMOOTHING_FACTOR = 0.4; 
        
        let isGrabbing = false;
        let canRelease = false;
        const MIN_HOLD_DURATION = 1000; 

        let grabbedBody = null;
        let grabConstraint = null;
        
        // Velocity calculation for throwing
        const velocityBuffer = [];
        const VELOCITY_BUFFER_SIZE = 5;
        let handVelocity = { x: 0, y: 0 };
        const THROW_MULTIPLIER = 4.5; 
        
        let handLossTimeout = null; 
        const HAND_LOSS_DELAY = 300; 
        let handVisibilityTimeout = null;
        const HAND_VISIBILITY_DELAY = 2000;

        let canThrow = false;
        const MIN_GRAB_DURATION_FOR_THROW = 1000;

        const GRAB_THRESHOLD = 0.05;

        // --- Utility ---
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // --- Main Initialization ---
        function setup() {
            canvasElement.width = gameContainer.clientWidth;
            canvasElement.height = gameContainer.clientHeight;
            
            engine = Engine.create();
            engine.world.gravity.y = 1;

            const wallThickness = 100;
            const ground = Bodies.rectangle(canvasElement.width / 2, canvasElement.height + wallThickness / 2, canvasElement.width * 2, wallThickness, { isStatic: true, render: { visible: false } });
            const wallLeft = Bodies.rectangle(-wallThickness / 2, canvasElement.height / 2, wallThickness, canvasElement.height * 2, { isStatic: true, render: { visible: false } });
            const wallRight = Bodies.rectangle(canvasElement.width + wallThickness / 2, canvasElement.height / 2, wallThickness, canvasElement.height * 2, { isStatic: true, render: { visible: false } });
            const ceiling = Bodies.rectangle(canvasElement.width / 2, -wallThickness / 2, canvasElement.width * 2, wallThickness, { isStatic: true, render: { visible: false } });
            
            World.add(engine.world, [ground, wallLeft, wallRight, ceiling]);

            resetGame();

            runner = Runner.create();
            Runner.run(runner, engine);
            
            setupCollisionHandling();
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            // Clear everything
            World.clear(engine.world, false); 
            objects.length = 0;
            targets.length = 0;
            particles.length = 0;
            score = 0;
            totalTargets = 5;
            updateScore();
            
            // Re-add boundaries as they were cleared
            const wallThickness = 100;
            const ground = Bodies.rectangle(canvasElement.width / 2, canvasElement.height + wallThickness / 2, canvasElement.width * 2, wallThickness, { isStatic: true, render: { visible: false } });
            const wallLeft = Bodies.rectangle(-wallThickness / 2, canvasElement.height / 2, wallThickness, canvasElement.height * 2, { isStatic: true, render: { visible: false } });
            const wallRight = Bodies.rectangle(canvasElement.width + wallThickness / 2, canvasElement.height / 2, wallThickness, canvasElement.height * 2, { isStatic: true, render: { visible: false } });
            const ceiling = Bodies.rectangle(canvasElement.width / 2, -wallThickness / 2, canvasElement.width * 2, wallThickness, { isStatic: true, render: { visible: false } });
            World.add(engine.world, [ground, wallLeft, wallRight, ceiling]);

            addObjects();
            addTargets();
        }

        function addObjects() {
            const objectTypes = ['sphere', 'wood', 'spear', 'sword'];
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * (canvasElement.width * 0.6) + (canvasElement.width * 0.2);
                const y = Math.random() * (canvasElement.height / 3);
                const type = objectTypes[i % objectTypes.length];
                let body;
                
                switch (type) {
                    case 'sphere':
                        const radius = 25;
                        body = Bodies.circle(x, y, radius, { 
                            restitution: 0.8, 
                            friction: 0.01, 
                            render: { objectType: 'sphere', color: '#DD6B20', radius: radius }
                        });
                        break;
                    case 'wood':
                        const woodWidth = 100, woodHeight = 30;
                        body = Bodies.rectangle(x, y, woodWidth, woodHeight, { 
                            restitution: 0.4, 
                            friction: 0.1, 
                            render: { objectType: 'wood', width: woodWidth, height: woodHeight }
                        });
                        break;
                    case 'spear':
                         const spearLength = 150, spearWidth = 10;
                         body = Bodies.rectangle(x, y, spearLength, spearWidth, {
                             restitution: 0.2, 
                             friction: 0.05, 
                             render: { objectType: 'spear', width: spearLength, height: spearWidth }
                         });
                        break;
                    case 'sword':
                         const swordLength = 120, swordWidth = 15;
                         body = Bodies.rectangle(x, y, swordLength, swordWidth, {
                             restitution: 0.1, 
                             friction: 0.02,
                             render: { objectType: 'sword', width: swordLength, height: swordWidth }
                         });
                        break;
                }
                objects.push(body);
                World.add(engine.world, body);
            }
        }
        
        function addTargets() {
            const radius = 25;
            const padding = 40;

            const positions = [
                { x: padding, y: canvasElement.height * 0.3 },
                { x: padding, y: canvasElement.height * 0.65 },
                { x: canvasElement.width - padding, y: canvasElement.height * 0.3 },
                { x: canvasElement.width - padding, y: canvasElement.height * 0.65 },
                { x: canvasElement.width / 2, y: padding }
            ];

            positions.forEach(pos => {
                 const target = Bodies.circle(pos.x, pos.y, radius, {
                    isStatic: true,
                    isSensor: true,
                    render: { fillStyle: '#E53E3E', objectType: 'target' },
                    label: 'target'
                });
                targets.push(target);
                World.add(engine.world, target);
            });
        }

        function setupCollisionHandling() {
            Events.on(engine, 'collisionStart', (event) => {
                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    const { bodyA, bodyB } = pair;
                    
                    let targetBody = null;
                    let otherBody = null;

                    if (bodyA.label === 'target' && objects.includes(bodyB)) {
                        targetBody = bodyA;
                        otherBody = bodyB;
                    } else if (bodyB.label === 'target' && objects.includes(bodyA)) {
                        targetBody = bodyB;
                        otherBody = bodyA;
                    }

                    if (targetBody && otherBody.speed > 2) {
                        destroyTarget(targetBody);
                    }
                }
            });
        }

        function destroyTarget(targetBody) {
            const targetIndex = targets.indexOf(targetBody);
            if (targetIndex === -1) return;

            for(let i=0; i<15; i++) {
                particles.push({
                    x: targetBody.position.x,
                    y: targetBody.position.y,
                    radius: Math.random() * 3 + 1,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    alpha: 1
                });
            }

            World.remove(engine.world, targetBody);
            targets.splice(targetIndex, 1);
            
            score++;
            updateScore();

            if (score === totalTargets) {
                messageText.textContent = "You Win! All targets destroyed.";
                loader.style.display = 'none';
                messageOverlay.style.opacity = '1';
                messageOverlay.style.pointerEvents = 'auto';
            }
        }

        function updateScore() {
            scoreElement.textContent = `${score} / ${totalTargets}`;
        }
        
        // --- MediaPipe Hands Setup ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onHandResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 1280, height: 720
        });
        camera.start().then(() => {
            messageText.textContent = "Ready! Pinch to grab objects.";
            loader.style.display = 'none';
            setTimeout(() => { messageOverlay.style.opacity = '0'; messageOverlay.style.pointerEvents = 'none'; }, 1500);
        }).catch(err => {
            messageText.textContent = "Error: Camera not found or permission denied.";
            loader.style.display = 'none';
            console.error("Camera Error:", err);
        });

        function onHandResults(results) {
            rawHandLandmarks = (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) ? results.multiHandLandmarks[0] : null;
            if (rawHandLandmarks) {
                 if (handLossTimeout) { clearTimeout(handLossTimeout); handLossTimeout = null; }
            }
        }

        // --- Game Logic ---
        function smoothHand() {
             if (rawHandLandmarks) {
                if (handVisibilityTimeout) {
                    clearTimeout(handVisibilityTimeout);
                    handVisibilityTimeout = null;
                }

                if (!smoothedHandLandmarks) {
                    smoothedHandLandmarks = JSON.parse(JSON.stringify(rawHandLandmarks));
                } else {
                    for (let i = 0; i < rawHandLandmarks.length; i++) {
                        smoothedHandLandmarks[i].x = lerp(smoothedHandLandmarks[i].x, rawHandLandmarks[i].x, SMOOTHING_FACTOR);
                        smoothedHandLandmarks[i].y = lerp(smoothedHandLandmarks[i].y, rawHandLandmarks[i].y, SMOOTHING_FACTOR);
                        smoothedHandLandmarks[i].z = lerp(smoothedHandLandmarks[i].z, rawHandLandmarks[i].z, SMOOTHING_FACTOR);
                    }
                }
            } else if (smoothedHandLandmarks && !handVisibilityTimeout) {
                handVisibilityTimeout = setTimeout(() => {
                    smoothedHandLandmarks = null;
                    handVisibilityTimeout = null;
                }, HAND_VISIBILITY_DELAY);
            }
        }

        function handleGrab() {
            if (!smoothedHandLandmarks) {
                if (isGrabbing && grabConstraint && !handLossTimeout) {
                    handLossTimeout = setTimeout(() => {
                        World.remove(engine.world, grabConstraint);
                        if (grabbedBody && canThrow) { Body.setVelocity(grabbedBody, handVelocity); }
                        grabConstraint = null; grabbedBody = null; isGrabbing = false; canThrow = false; canRelease = false; velocityBuffer.length = 0; handLossTimeout = null;
                    }, HAND_LOSS_DELAY);
                }
                return;
            }

            const thumbTip = smoothedHandLandmarks[4];
            const indexTip = smoothedHandLandmarks[8];
            const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const grabPoint = { x: (1 - (thumbTip.x + indexTip.x) / 2) * canvasElement.width, y: ((thumbTip.y + indexTip.y) / 2) * canvasElement.height };
            
            // --- New Velocity Calculation Logic ---
            velocityBuffer.push({ ...grabPoint });
            if (velocityBuffer.length > VELOCITY_BUFFER_SIZE) {
                velocityBuffer.shift();
            }

            if (velocityBuffer.length > 1) {
                const firstPoint = velocityBuffer[0];
                const lastPoint = velocityBuffer[velocityBuffer.length - 1];
                const timeElapsed = velocityBuffer.length;
                // We use timeElapsed as a simple proxy for time. A larger buffer means a smoother but less instantaneous velocity.
                handVelocity.x = ((lastPoint.x - firstPoint.x) / timeElapsed) * THROW_MULTIPLIER;
                handVelocity.y = ((lastPoint.y - firstPoint.y) / timeElapsed) * THROW_MULTIPLIER;
            } else {
                handVelocity.x = 0;
                handVelocity.y = 0;
            }
            // --- End New Logic ---

            if (distance < GRAB_THRESHOLD && !isGrabbing) {
                const bodiesUnderPoint = Matter.Query.point(objects, grabPoint);
                if (bodiesUnderPoint.length > 0) {
                    const bodyToGrab = bodiesUnderPoint[0];
                    isGrabbing = true;
                    grabbedBody = bodyToGrab;
                    canThrow = false;
                    canRelease = false;
                    velocityBuffer.length = 0; // Clear buffer on new grab

                    setTimeout(() => { if (isGrabbing && grabbedBody === bodyToGrab) canRelease = true; }, MIN_HOLD_DURATION);
                    setTimeout(() => { if (isGrabbing && grabbedBody === bodyToGrab) canThrow = true; }, MIN_GRAB_DURATION_FOR_THROW);

                    grabConstraint = Constraint.create({
                        pointA: grabPoint, bodyB: grabbedBody, stiffness: 0.9, length: 0, // Increased stiffness
                        render: { visible: false }
                    });
                    World.add(engine.world, grabConstraint);
                }
            } else if (distance >= GRAB_THRESHOLD && isGrabbing && canRelease) {
                if (grabConstraint) {
                    World.remove(engine.world, grabConstraint);
                    if (grabbedBody && canThrow) { Body.setVelocity(grabbedBody, handVelocity); }
                    grabConstraint = null; grabbedBody = null; isGrabbing = false; canThrow = false; canRelease = false; velocityBuffer.length = 0;
                }
            }
            
            if (isGrabbing && grabConstraint) {
                grabConstraint.pointA = { ...grabPoint };
                Body.setAngularVelocity(grabbedBody, 0); 
            }
        }

        function renderRealisticObjects() {
            objects.forEach(body => {
                const { position, angle } = body;
                const { objectType } = body.render;

                canvasCtx.save();
                canvasCtx.translate(position.x, position.y);
                canvasCtx.rotate(angle);

                switch (objectType) {
                    case 'sphere':
                        const radius = body.render.radius;
                        const gradient = canvasCtx.createRadialGradient(-radius/3, -radius/3, 1, 0, 0, radius);
                        gradient.addColorStop(0, tinycolor(body.render.color).lighten(20).toString());
                        gradient.addColorStop(1, body.render.color);
                        canvasCtx.beginPath();
                        canvasCtx.arc(0, 0, radius, 0, Math.PI * 2);
                        canvasCtx.fillStyle = gradient;
                        canvasCtx.fill();
                        canvasCtx.strokeStyle = tinycolor(body.render.color).darken(15).toString();
                        canvasCtx.lineWidth = 2;
                        canvasCtx.stroke();
                        break;

                    case 'wood':
                        const w = body.render.width;
                        const h = body.render.height;
                        canvasCtx.fillStyle = '#8C6E4A';
                        canvasCtx.fillRect(-w/2, -h/2, w, h);
                        canvasCtx.strokeStyle = '#6B4F2E';
                        canvasCtx.lineWidth = 1.5;
                        for(let i = 0; i < 5; i++) {
                            canvasCtx.beginPath();
                            canvasCtx.moveTo(-w/2, -h/2 + (i/4)*h + (Math.random()-0.5)*4);
                            canvasCtx.bezierCurveTo(-w/4, -h/2 + (i/4)*h, w/4, -h/2 + (i/4)*h, w/2, -h/2 + (i/4)*h + (Math.random()-0.5)*4);
                            canvasCtx.stroke();
                        }
                        canvasCtx.strokeStyle = '#543D21';
                        canvasCtx.lineWidth = 3;
                        canvasCtx.strokeRect(-w/2, -h/2, w, h);
                        break;
                    
                    case 'spear':
                        const spearW = body.render.width;
                        const spearH = body.render.height;
                        canvasCtx.fillStyle = '#6B4F2E';
                        canvasCtx.fillRect(-spearW/2, -spearH/2, spearW, spearH);
                        canvasCtx.strokeStyle = '#543D21';
                        canvasCtx.lineWidth = 1;
                        canvasCtx.strokeRect(-spearW/2, -spearH/2, spearW, spearH);
                        const tipLength = 30;
                        canvasCtx.fillStyle = '#A0AEC0';
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(spearW/2, 0);
                        canvasCtx.lineTo(spearW/2 - tipLength, -spearH/2 - 4);
                        canvasCtx.lineTo(spearW/2 - tipLength, spearH/2 + 4);
                        canvasCtx.closePath();
                        canvasCtx.fill();
                        canvasCtx.strokeStyle = '#4A5568';
                        canvasCtx.stroke();
                        break;

                    case 'sword':
                        const swordW = body.render.width;
                        const swordH = body.render.height;
                        const bladeGradient = canvasCtx.createLinearGradient(0, -swordH/2, 0, swordH/2);
                        bladeGradient.addColorStop(0, '#E2E8F0');
                        bladeGradient.addColorStop(0.5, '#A0AEC0');
                        bladeGradient.addColorStop(1, '#E2E8F0');
                        canvasCtx.fillStyle = bladeGradient;
                        const bladeLength = swordW * 0.75;
                        canvasCtx.fillRect(-swordW/2, -swordH/2, bladeLength, swordH);
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(swordW/2 - bladeLength, -swordH/2);
                        canvasCtx.lineTo(swordW/2, 0);
                        canvasCtx.lineTo(swordW/2 - bladeLength, swordH/2);
                        canvasCtx.closePath();
                        canvasCtx.fill();
                        canvasCtx.fillStyle = '#7A4F38';
                        canvasCtx.fillRect(-swordW/2, -swordH/2 - 5, 10, swordH + 10);
                        canvasCtx.fillStyle = '#4A2E1C';
                        canvasCtx.fillRect(-swordW/2 - 25, -swordH/2 + 2, 25, swordH - 4);
                        break;
                }
                canvasCtx.restore();
            });
        }
        
        function renderTargets() {
            targets.forEach(target => {
                const pos = target.position;
                const radius = target.circleRadius;
                let gradient = canvasCtx.createRadialGradient(pos.x, pos.y, radius * 0.7, pos.x, pos.y, radius);
                gradient.addColorStop(0, '#F56565');
                gradient.addColorStop(1, '#C53030');
                canvasCtx.fillStyle = gradient;
                canvasCtx.beginPath();
                canvasCtx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                canvasCtx.fill();
                canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                canvasCtx.beginPath();
                canvasCtx.arc(pos.x - 5, pos.y - 5, radius * 0.8, 0, 2 * Math.PI);
                canvasCtx.fill();
            });
        }
        
        function renderParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.04;
                if (p.alpha <= 0) {
                    particles.splice(i, 1);
                } else {
                    canvasCtx.fillStyle = `rgba(229, 62, 62, ${p.alpha})`;
                    canvasCtx.beginPath();
                    canvasCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    canvasCtx.fill();
                }
            }
        }
        
        // --- Main Render Loop ---
        function gameLoop() {
            smoothHand();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            handleGrab();
            renderRealisticObjects();
            renderTargets();
            renderParticles();

            if (smoothedHandLandmarks) {
                const thumbTip = smoothedHandLandmarks[4];
                const indexTip = smoothedHandLandmarks[8];
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const grabPoint = { x: (1 - (thumbTip.x + indexTip.x) / 2) * canvasElement.width, y: ((thumbTip.y + indexTip.y) / 2) * canvasElement.height };
                const isPinching = distance < GRAB_THRESHOLD;
                
                canvasCtx.beginPath();
                canvasCtx.arc(grabPoint.x, grabPoint.y, 15, 0, 2 * Math.PI);
                canvasCtx.fillStyle = isPinching ? 'rgba(56, 178, 172, 0.8)' : 'rgba(255, 255, 255, 0.3)';
                canvasCtx.fill();
                if (isPinching) { canvasCtx.strokeStyle = '#66FCF1'; canvasCtx.lineWidth = 3; canvasCtx.stroke(); }
            
                if (grabConstraint) {
                     canvasCtx.beginPath();
                     canvasCtx.moveTo(grabConstraint.pointA.x, grabConstraint.pointA.y);
                     canvasCtx.lineTo(grabConstraint.bodyB.position.x, grabConstraint.bodyB.position.y);
                     canvasCtx.strokeStyle = canThrow ? '#34D399' : '#38B2AC';
                     canvasCtx.lineWidth = 3;
                     canvasCtx.stroke();
                }

                canvasCtx.save();
                canvasCtx.scale(-1, 1);
                canvasCtx.translate(-canvasElement.width, 0);
                drawConnectors(canvasCtx, smoothedHandLandmarks, HAND_CONNECTIONS, { color: 'rgba(255, 255, 255, 0.6)', lineWidth: 3 });
                drawLandmarks(canvasCtx, smoothedHandLandmarks, { color: '#38B2AC', lineWidth: 1, radius: 4 });
                canvasCtx.restore();
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        resetButton.addEventListener('click', () => {
            messageOverlay.style.opacity = '0';
            messageOverlay.style.pointerEvents = 'none';
            resetGame();
        });
        
        window.addEventListener('resize', () => {
            if (runner) Runner.stop(runner);
            if (engine) World.clear(engine.world);
            if (engine) Engine.clear(engine);
            setup();
        });

        // --- Start Everything ---
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.6.0/tinycolor.min.js';
        script.onload = () => { setup(); };
        document.head.appendChild(script);

    </script>
</body>
</html>

